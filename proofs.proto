option java_outer_classname = "Serialization";
option java_package = "org.rice.crosby.historytree.generated";

// A configuration message for an aggregator. An aggobj generates a config blob, which 
// is placed in this message along with its name.

/*
message AggConfig {
  required string name = 1;
  optional bytes configblob =2;
 }

message Config {
  required AggConfig aggconfig = 1;
  required string valtype = 2;
}
*/


// For serializing a pruned tree. 
message HistNode {
     optional HistNode left = 1;
     optional HistNode right = 2;
 
     // Leaves must include either a value or an agg.
     // Interior non-frozen never include a value or agg.
     // Interior non-stubs never include a value or an agg.
     // Interior frozen stubs include an agg.
     optional bytes val = 3;
     optional bytes agg = 4;
}

message PrunedTree {
     optional int32 version = 1; // Optional for merkle tree, required for the history tree
     required HistNode root = 2; // Root node.
}


/* What is the type of the tree in the signature?
   Its either Merkle or History.
*/

enum SigTreeType {HISTORY_TREE = 1;  MERKLE_TREE = 2; };

/* What is the type of the tree in the proof?
   For now, merkle or history, but we only prove a single message per tree signature proof blob
*/

enum TreeType {SINGLE_HISTORY_TREE = 1;  SINGLE_MERKLE_TREE = 2; };


// What is signed. (but is not sent)
message TreeSigMessage {
     required SigTreeType treetype = 1;
     optional int32 version = 3;
     optional bytes roothash = 4;
}

// What is sent.
message TreeSigBlob {
   optional TreeType treetype = 1;
   optional bytes sig = 2;
   optional PrunedTree tree = 3;
   optional int32 leaf = 4; //Point out specific leafs.

   // For a history tree, used to demultiplex
   optional sfixed64 tree_id = 16;
   repeated int32 splice_hint = 17;
}




////////////////
////////////////   Stream signature design.
////////////////

/*
message StreamBundle {
   repeated int32 splicepoints=2; // Includes the end of the last epoch.
   required Commitment commitment=3;
   required bytes signature = 4;
}

// Represents a signature over a single version.
message SigBlob {
   repeated int32 messageversion = 1;
   required Commitment commitment = 2;
}
*/
